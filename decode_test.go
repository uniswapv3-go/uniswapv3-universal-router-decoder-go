package uniswapv3_universal_router_decoder_go

import (
	"encoding/json"
	"github.com/ethereum/go-ethereum/common/hexutil"
	"github.com/stretchr/testify/require"
	"github.com/uniswapv3-go/uniswapv3-universal-router-decoder-go/command"
	v2 "github.com/uniswapv3-go/uniswapv3-universal-router-decoder-go/uniswap/v2"
	v3 "github.com/uniswapv3-go/uniswapv3-universal-router-decoder-go/uniswap/v3"
	"testing"
)

func TestDecode2(t *testing.T) {
	inputs := []string{
		"0x3593564c000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000649a4ce40000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000001a1e7350d8a177dd00000000000000000000000000000000000000000000000001612682ff5a7c0100000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000002b1f9840a85d5af5bf1d1762f925bdaddc4201f9840001f4b4fbf271143f4fbf7b91a5ded31805e42b2208d6000000000000000000000000000000000000000000",
		"0x3593564c000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000649ac190000000000000000000000000000000000000000000000000000000000000000101000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000016345785d8a00000000000000000000000000000000000000000000000000000012ec55a96cb50000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000002b1f9840a85d5af5bf1d1762f925bdaddc4201f9840001f4b4fbf271143f4fbf7b91a5ded31805e42b2208d6000000000000000000000000000000000000000000",
		// v2 swap exact in, unwrap weth
		"0x3593564c000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000649d4a740000000000000000000000000000000000000000000000000000000000000002080c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000001600000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000010f0cf064dd5920000000000000000000000000000000000000000000000000000042727c5230c6fead00000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000009b2660a7becd0bf3d90401d1c214d2cd36317da5000000000000000000000000b4fbf271143f4fbf7b91a5ded31805e42b2208d60000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000042727c5230c6fead",
	}
	for i, input := range inputs {
		t.Logf("[%d] %s", i, input)
		decoded, err := hexutil.Decode(input)
		require.NoError(t, err)
		cs, err := Decode(decoded)
		require.NoError(t, err)
		for j, cc := range cs {
			t.Logf("[%d][%d] command: %x => %s", i, j, cc.Command, command.RealCommandName(cc.Command))
			t.Logf("%d inputs", len(cc.Input))
			//for k, p := range cc.Input {
			//	t.Logf("[%d][%d][%d] input: %s", i, j, k, string(p))
			//}
			switch command.RealCommand(cc.Command) {
			case command.V3_SWAP_EXACT_IN:
				var params v3.SwapRouterExactInputParams
				err = v3.UnpackV3SwapExactIn(&params, cc.Input)
				require.NoError(t, err)
				b, err := json.MarshalIndent(params, "", "  ")
				require.NoError(t, err)
				t.Logf("%s", string(b))
			case command.V3_SWAP_EXACT_OUT:
				var params v3.SwapRouterExactOutputParams
				err = v3.UnpackV3SwapExactOut(&params, cc.Input)
				require.NoError(t, err)
				b, err := json.MarshalIndent(params, "", "  ")
				require.NoError(t, err)
				t.Logf("%s", string(b))
			case command.V2_SWAP_EXACT_IN:
				var params v2.SwapRouterExactInputParams
				err = v2.UnpackV2SwapExactIn(&params, cc.Input)
				require.NoError(t, err)
				b, err := json.MarshalIndent(params, "", "  ")
				require.NoError(t, err)
				t.Logf("%s", string(b))
			case command.V2_SWAP_EXACT_OUT:
				var params v2.SwapRouterExactOutputParams
				err = v2.UnpackV2SwapExactOut(&params, cc.Input)
				require.NoError(t, err)
				b, err := json.MarshalIndent(params, "", "  ")
				require.NoError(t, err)
				t.Logf("%s", string(b))
			}
		}
	}
}
